<#@ template hostspecific="true" language="C#" #>
<#@ output extension=".cs"#>
<#@ include file="BuilderCommon.ttinclude"
#><#@ assembly name="System.Xml" #>
<#@ assembly name="System.Core"#>
<#@ import namespace="System.Linq"#>
<#
    void CreateBody(int opCode, List<(SPIRVOperand operand, string name)> paramInfos)
    {
#> {
<#
        PushIndent(standardIndent);
        if (paramInfos.Count != 0)
        {
#>var tempList = new List<uint>();
<#
        }

        foreach (var (_, name) in paramInfos)
        {
#>tempList.AddRange(SPIRVBuilderUtils.ToUintList(<#= name #>));
<#
        }
#><#// Add 1 to the word count for the first word (what we are creating here)#>
ushort opCode = <#= opCode#>;
<#
        if (paramInfos.Count != 0)
        {
#>ushort wordCount = (ushort) (tempList.Count + 1);
<#
        }
        else
        {
#>ushort wordCount = 1;
<#
        }
#>
uint combinedWord = SPIRVBuilderUtils.JoinOpCodeWordCount(opCode, wordCount);
_instructions.Add(combinedWord);
<#
        if (paramInfos.Count != 0)
        {
#>_instructions.AddRange(tempList);
<#
        }
#>
<#
        PopIndent();
#>
}

<#
    }
#>
using System;
using System.Collections.Generic;

#nullable enable
#pragma warning disable 1591

namespace ILGPU.Backends.SPIRV {

<#
    PushIndent(standardIndent);
#>
/// <summary>
/// Defines utility methods to generate SPIRV operations
/// </summary>
[CLSCompliant(false)]
public class BinarySPIRVBuilder : ISPIRVBuilder {

    private List<uint> _instructions = new List<uint>();

    public byte[] ToByteArray() {
        uint[] uintArray = _instructions.ToArray();
        byte[] byteArray = new byte[uintArray.Length * 4];
        Buffer.BlockCopy(uintArray, 0, byteArray, 0, uintArray.Length * 4);
        return byteArray;
    }

    public void AddMetadata(
        uint magic,
        uint version,
        uint genMagic,
        uint bound,
        uint schema)
    {
        _instructions.Add(magic);
        _instructions.Add(version);
        _instructions.Add(genMagic);
        _instructions.Add(bound);
        _instructions.Add(schema);
    }

    public void Merge(ISPIRVBuilder other) {
        if(other == null) {
            throw new ArgumentNullException();
        }

        var otherBinary = other as BinarySPIRVBuilder;
        if(otherBinary == null) {
            throw new InvalidCodeGenerationException(
                "Attempted to merge string representation builder with binary builder"
            );
        }

        _instructions.AddRange(otherBinary._instructions);
    }

<#
    PushIndent(standardIndent);
    foreach (var instruction in grammar.Instructions.Instructions)
    {
        if (!IsInstructionCLSCompliant(instruction))
        {
#>[CLSCompliant(false)]
<#
        }

        var paramInfos = GenerateParamInfos(instruction);
        CreateHeader(instruction.OpName, paramInfos);
        CreateBody(instruction.OpCode, paramInfos);
    }
    PopIndent();
#>
}
<#
    PopIndent();
#>
}
#pragma warning restore 1591