<#@ include file="SPIRVXMLReader.ttinclude"
#><#+
    Dictionary<string, string> _typeMapCache = null;

    Dictionary<string, string> LoadTypeMap()
    {
        if (_typeMapCache != null)
        {
            return _typeMapCache;
        }

        var grammar = LoadGrammar();
        var typeMap = new Dictionary<string, string>();

        foreach (var kind in grammar.Types.Types)
        {
            typeMap[kind.Name] = kind.Category switch
            {
                "Id" => MapIdType(),
                "Literal" => MapLiteralType(kind.Name),
                _ => MapComplexType(kind.Name)
            };
        }

        _typeMapCache = typeMap;
        return typeMap;
    }

    string MapIdType()
    {
        return "uint";
    }

    string MapLiteralType(string type)
    {
        string paramType = "object";

        switch (type)
        {
            case "LiteralSpecConstantOpInteger":
            case "LiteralInteger":
                paramType = "uint";
                break;
            case "LiteralString":
                paramType = "string";
                break;
            case "LiteralContextDependentNumber":
                paramType = "double";
                break;
            case "LiteralExtInstInteger":
                paramType = "uint";
                break;
        }

        return paramType;
    }

    string MapComplexType(string type)
    {
        //Complex types are generate by SPIRVComplexTypes.tt
        return type;
    }
#>
<#+
    Dictionary<string, bool> _clsMapCache = null;
    readonly List<string> _nonClsCompliantPrimTypes = new List<string> {"sbyte", "uint", "ulong", "ushort"};

    Dictionary<string, bool> LoadCLSComplianceMap()
    {
        if (_clsMapCache != null)
        {
            return _clsMapCache;
        }

        var grammar = LoadGrammar();
        var typeMap = LoadTypeMap();
        var clsMap = new Dictionary<string, bool>();

        foreach (var kind in grammar.Types.Types)
        {
            var typename = kind.Name;

            if (kind.Bases?.Bases != null)
            {
                clsMap[typename] = kind.Bases.Bases.TrueForAll(
                    t => !_nonClsCompliantPrimTypes.Contains(typeMap[t]));
            }

            if (_nonClsCompliantPrimTypes.Contains(typeMap[typename]))
            {
                clsMap[typename] = false;
                continue;
            }
            clsMap[typename] = true;
        }

        _clsMapCache = clsMap;
        return clsMap;
    }

    bool IsCLSCompliant(string type)
    {
        var map = LoadCLSComplianceMap();
        return map[type];
    }
#>
<#+
    Dictionary<string, SPIRVType> _infoMapCache = null;

    Dictionary<string, SPIRVType> LoadOperandTypeInfoMap()
    {
        if (_infoMapCache != null)
        {
            return _infoMapCache;
        }

        var grammar = LoadGrammar();
        var infoMap = new Dictionary<string, SPIRVType>();

        foreach (var instruction in grammar.Instructions.Instructions)
        {
            if (instruction.Operands?.Operands == null)
            {
                continue;
            }

            foreach (var operand in instruction.Operands.Operands)
            {
                var type = grammar.Types.Types.Find(x => x.Name == operand.Type);
                infoMap[operand.Type] = type;
            }
        }

        _infoMapCache = infoMap;
        return infoMap;
    }
#>